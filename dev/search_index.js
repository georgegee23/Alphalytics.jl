var documenterSearchIndex = {"docs":
[{"location":"#Alphalytics","page":"Home","title":"Alphalytics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Alphalytics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Alphalytics.consecutive_values-Tuple{AbstractMatrix, Any, Int64}","page":"Home","title":"Alphalytics.consecutive_values","text":"consecutive_values(mtx::AbstractMatrix, target::Any, n::Int) -> Vector{Bool}\n\nCheck each column of the matrix mtx for at least n consecutive occurrences of target.\n\nArguments\n\nmtx::AbstractMatrix: The input matrix to search (columns are checked independently).\ntarget::Any: The value to look for consecutive occurrences of.\nn::Int: The number of consecutive occurrences required.\n\nReturns\n\nVector{Bool}: A boolean vector where each element indicates if the corresponding column contains at least n consecutive target values.\n\nExample\n\nmtx = [0 1; 1 1; 1 0; 1 1]\nconsecutive_values(mtx, 1, 3) # returns [true, true]\n\n\n\n\n\n","category":"method"},{"location":"#Alphalytics.consecutive_values-Tuple{AbstractVector, Any, Int64}","page":"Home","title":"Alphalytics.consecutive_values","text":"consecutive_values(ta::AbstractVector, target::Any, n::Int) -> Bool\n\nCheck if there are at least n consecutive occurrences of target in the vector ta.\n\nArguments\n\nta::AbstractVector: The input vector to search.\ntarget::Any: The value to look for consecutive occurrences of.\nn::Int: The number of consecutive occurrences required.\n\nReturns\n\nBool: Returns true if target appears at least n times in a row in ta, otherwise false.\n\nExample\n\nta = [0, 1, 1, 1, 0, 1, 1]\nconsecutive_values(ta, 1, 3) # returns true\nconsecutive_values(ta, 0, 2) # returns false\n\n\n\n\n\n","category":"method"},{"location":"#Alphalytics.consecutive_values-Tuple{TimeSeries.TimeArray, Any, Int64}","page":"Home","title":"Alphalytics.consecutive_values","text":"consecutive_values(ta::TimeArray, target::Any, n::Int) -> Vector{Bool}\n\nCheck each column of the TimeArray for at least n consecutive occurrences of target.\n\nArguments\n\nta::TimeArray: The input TimeArray to search (columns are checked independently).\ntarget::Any: The value to look for consecutive occurrences of.\nn::Int: The number of consecutive occurrences required.\n\nReturns\n\nVector{Bool}: A boolean vector where each element indicates if the corresponding column contains at least n consecutive target values.\n\nExample\n\nconsecutive_values(returns_ts, 0, 10)\n\n\n\n\n\n","category":"method"},{"location":"#Alphalytics.returns_to_prices","page":"Home","title":"Alphalytics.returns_to_prices","text":"returns_to_prices(returns::TimeArray, init_value::Int = 1) -> TimeArray\n\nCompute the cumulative product of returns, preserving NaN locations.\n\nThis function treats the input as returns (as decimals or percentages), so it adds 1 to each value before multiplying.   NaN values are preserved in the output, and the cumulative product continues from the last non-NaN value after a NaN.\n\nArguments\n\nreturns::TimeArray: TimeArray containing return data with possible NaN values.\ninit_value::Int: Initial value for the cumulative product (default: 1).\n\nReturns\n\nTimeArray: TimeArray with cumulative products, preserving NaN locations.\n\nExample\n\nta = TimeArray([0.1, NaN, 0.05, -0.02], timestamp=1:4, colnames=[:R])\nreturns_to_prices(ta)\n\n\n\n\n\n","category":"function"},{"location":"#Alphalytics.rowwise_ordinal_pctrank-Tuple{TimeSeries.TimeArray}","page":"Home","title":"Alphalytics.rowwise_ordinal_pctrank","text":"rowwise_ordinal_pctrank(ta::TimeArray) -> TimeArray\n\nCompute ordinal percentile ranks for each value in the TimeArray along rows, ignoring NaNs.\n\nFor each row, non-NaN values are ranked ordinally, and their percentile rank is calculated as (ordinal rank) / (maximum rank in the row). NaN values are preserved in their original positions.\n\nArguments\n\nta::TimeArray: TimeArray containing numerical data.\n\nReturns\n\nTimeArray: A new TimeArray with ordinal percentile ranks for each row.\n\nNotes\n\nRows with only one non-NaN value will result in NaN for that row's percentile calculation.\nNaN values are preserved in their original positions.\n\nExample\n\nta = TimeArray([1.0 3.0 NaN; 2.0 1.0 4.0], timestamp=1:2, colnames=[:A, :B, :C])\nrowwise_ordinal_pctrank(ta)\n\n\n\n\n\n","category":"method"},{"location":"#Alphalytics.rowwise_tied_pctrank-Tuple{TimeSeries.TimeArray}","page":"Home","title":"Alphalytics.rowwise_tied_pctrank","text":"rowwise_tied_pctrank(ta::TimeArray) -> TimeArray\n\nCompute tied percentile ranks for each value in the TimeArray along rows, ignoring NaNs.\n\nFor each row, non-NaN values are ranked using tied ranking, and their percentile rank is calculated as (tied rank) / (maximum rank in the row). NaN values are preserved in their original positions.\n\nArguments\n\nta::TimeArray: TimeArray containing numerical data.\n\nReturns\n\nTimeArray: A new TimeArray with tied percentile ranks for each row.\n\nNotes\n\nRows with only one non-NaN value will result in NaN for that row's percentile calculation.\nNaN values are preserved in their original positions.\n\nExample\n\nta = TimeArray([1.0 3.0 NaN; 2.0 1.0 4.0], timestamp=1:2, colnames=[:A, :B, :C])\nrowwise_tied_pctrank(ta)\n\n\n\n\n\n","category":"method"}]
}
